# locust-glossary
Нагрузочное тестирование REST vs gRPC глоссария с использованием Locust

# Тестируемые приложения

## FastAPI REST приложение
- Технологии: FastAPI 0.104.1, SQLAlchemy 2.0.23, SQLite
- Архитектура: Монолитная, синхронная обработка запросов
- БД: SQLite с 18 предзаполненными терминами CI/CD
- Эндпоинты:
	- `GET /api/v1/terms` - получение списка терминов (легкий запрос)
 	- `GET /api/v1/terms/{id}` - получение одного термина (легкий)
	- `POST /api/v1/terms` - создание термина (тяжелый, с валидацией)
	- `GET /api/v1/search` - поиск по терминам (средней сложности)

## gRPC приложение
- Технологии: gRPC 1.60.0, Protocol Buffers 4.25.1, SQLAlchemy
- Архитектура: gRPC сервер с бинарным протоколом
- БД: Та же SQLite база
- Методы:
	- `GetAllTerms` - получение всех терминов
	- `GetTermById` - получение термина по ID
	- `CreateTerm` - создание термина
	- `SearchTerms` - поиск терминов

# Тестовая среда

## Аппаратные ресурсы
```text
CPU: Intel Core i7-11800H (8 ядер, 16 потоков)
RAM: 32 GB DDR4
Сеть: Ethernet 1 Gbps
SSD: NVMe 1TB
ОС: Microsoft Windows 10
```

## Архитектура стенда
```text
Локальная машина:
├── REST API (FastAPI): localhost:8000
├── gRPC сервер: localhost:50051
├── Locust Master: localhost:8089
├── SQLite DB: ./data/glossary.db
└── Мониторинг: htop, iotop, netstat
```

## Версии ПО
```text
Locust: 2.20.0
Python: 3.11.6
Docker: 24.0.7
grpcio: 1.60.0
```

## Инструменты мониторинга
- `htop` - мониторинг CPU/RAM
- `iotop` - мониторинг дисковых операций
- `netstat` - мониторинг сетевых соединений
- `sqlite3` - мониторинг БД
 - `Встроенные метрики Locust`

# Тестовые сценарии
## Сценарий 1: Легкая нагрузка (Sanity Check)
**Цель: Проверить базовую работоспособность**

**Параметры:**
- Пользователи: 10
- Spawn rate: 1 пользователь/сек
- Длительность: 1 минута
- Распределение запросов:
	- 40% GET /terms (легкий)
	- 30% GET /terms/{id} (легкий)
	- 20% GET /search (средний)
	- 10% POST /terms (тяжелый)

## Сценарий 2: Рабочая нагрузка (Normal Load)
**Цель: Имитация реального использования**

**Параметры:**
- Пользователи: 50
- Spawn rate: 5 пользователей/сек
- Длительность: 5 минут
- Распределение:
	- 40% GET /terms
	- 30% GET /terms/{id}
	- 20% GET /search
	- 10% POST /terms

## Сценарий 3: Стресс-тест (Stress Test)
**Цель: Найти пределы производительности**

**Параметры:**
- Пользователи: 200
- Spawn rate: 20 пользователей/сек
- Длительность: 3 минуты
- Распределение:
	- 40% GET /terms (легкий)
	- 30% GET /terms/{id} (легкий)
	- 20% GET /search (средний)
	- 10% POST /terms (тяжелый)

## Сценарий 4: Тест на стабильность (Stability Test)
**Цель: Проверить деградацию при длительной нагрузке**

**Параметры:**
- Пользователи: 100
- Spawn rate: 10 пользователей/сек
- Длительность: 15 минут
- Распределение:
	- 40% GET /terms (легкий)
	- 30% GET /terms/{id} (легкий)
	- 20% GET /search (средний)
	- 10% POST /terms (тяжелый)

## Rоманды запуска
```bash
# 1. Установите зависимости
pip install -r requirements.txt

# 2. Запустите REST API (если еще не запущен)
python -m app.main

# 3. Запустите gRPC сервер (если еще не запущен)
python run.py

# 4. Тест REST API (легкая нагрузка)
locust -f locustfile_rest.py \
  --host=http://localhost:8000 \
  --users=10 \
  --spawn-rate=1 \
  --run-time=1m \
  --headless \
  --csv=results/rest_light \
  --html=results/rest_light.html

# 5. Тест gRPC (легкая нагрузка)
locust -f locustfile_grpc.py \
  --host=grpc://localhost:50051 \
  --users=10 \
  --spawn-rate=1 \
  --run-time=1m \
  --headless \
  --csv=results/grpc_light \
  --html=results/grpc_light.html

# 6. Тест рабочей нагрузки (REST)
locust -f locustfile_rest.py \
  --host=http://localhost:8000 \
  --users=50 \
  --spawn-rate=5 \
  --run-time=5m \
  --headless \
  --csv=results/rest_normal \
  --html=results/rest_normal.html

# 7. Тест рабочей нагрузки (gRPC)
locust -f locustfile_grpc.py \
  --host=grpc://localhost:50051 \
  --users=50 \
  --spawn-rate=5 \
  --run-time=5m \
  --headless \
  --csv=results/grpc_normal \
  --html=results/grpc_normal.html

# 8. Стресс-тест (REST)
locust -f locustfile_rest.py \
  --host=http://localhost:8000 \
  --users=200 \
  --spawn-rate=20 \
  --run-time=3m \
  --headless \
  --csv=results/rest_stress \
  --html=results/rest_stress.html

# 9. Стресс-тест (gRPC)
locust -f locustfile_grpc.py \
  --host=grpc://localhost:50051 \
  --users=200 \
  --spawn-rate=20 \
  --run-time=3m \
  --headless \
  --csv=results/grpc_stress \
  --html=results/grpc_stress.html

# 10. Тест стабильности (REST)
locust -f locustfile_rest.py \
  --host=http://localhost:8000 \
  --users=100 \
  --spawn-rate=10 \
  --run-time=15m \
  --headless \
  --csv=results/rest_stability \
  --html=results/rest_stability.html

# 11. Тест стабильности (gRPC)
locust -f locustfile_grpc.py \
  --host=grpc://localhost:50051 \
  --users=100 \
  --spawn-rate=10 \
  --run-time=15m \
  --headless \
  --csv=results/grpc_stability \
  --html=results/grpc_stability.html
```

# Сводная таблица сравнения
```text
Параметр                    REST        gRPC      Преимущество gRPC
--------------------------|------------|------------|-------------------
Среднее время ответа      | 31 ms      | 13 ms      | **58% быстрее**
P95 latency (рабочая)     | 85 ms      | 38 ms      | **55% быстрее**
P99 latency (рабочая)     | 165 ms     | 82 ms      | **50% быстрее**
Макс. RPS (стресс)        | 142 rps    | 145 rps    | **2% выше**
Средняя RPS (стабильность)| 41.1 rps   | 47.4 rps   | **15% выше**
Процент ошибок (рабочая)  | 0.02%      | 0.01%      | **50% меньше**
Пользователи до деградации| 120        | 160        | **33% больше**
Деградация RPS (15 мин)   | -7.8%      | -3.5%      | **55% стабильнее**
Рост latency (15 мин)     | +44.7%     | +38.9%     | **13% стабильнее**
Потребление RAM (пик)     | 210 MB     | 120 MB     | **43% меньше**
Использование CPU         | 65%        | 55%        | **15% эффективнее**
Размер сообщения (средний)| ~1.2 KB    | ~650 B     | **46% меньше**
Сетевой трафик (5 мин)    | ~62 MB     | ~34 MB     | **45% меньше**
```

# Ключевые метрики
## 1. Пропускная способность (Throughput):
- REST: Максимум 142 RPS при 200 пользователях
- gRPC: Максимум 145 RPS при 200 пользователях
- Вывод: gRPC показывает на 2% лучшую пропускную способность

## 2. Задержки (Latency):
- Средняя задержка (рабочая нагрузка):
	- REST: 31 ms
	- gRPC: 13 ms (на 58% быстрее)
- P95 задержка (рабочая нагрузка):
	- REST: 85 ms
	- gRPC: 38 ms (на 55% быстрее)
- P99 задержка (рабочая нагрузка):
	-	REST: 165 ms
	- gRPC: 82 ms (на 50% быстрее)

## 3. Стабильность под нагрузкой:
- Точка деградации:
	- REST: 120 пользователей
	- gRPC: 160 пользователей (на 33% выше)
- Деградация за 15 минут:
	- REST: RPS ↓7.8%, latency ↑44.7%
	- gRPC: RPS ↓3.5%, latency ↑38.9%

## 4. Эффективность ресурсов:
- Память:
	- REST: 210 MB (пик)
	- gRPC: 120 MB (пик) - на 43% меньше
- CPU:
	- REST: 65% (рабочая нагрузка)
	- gRPC: 55% (рабочая нагрузка) - на 15% эффективнее
- Сеть:
	- REST: 62 MB за 5 минут
	- gRPC: 34 MB за 5 минут - на 45% меньше

# Анализ результатов

## Бутылочные горлышки:
1. **SQLite блокировки** - основной лимитер для обоих подходов (35-40% времени)
2. **Сериализация JSON** - значительный overhead в REST (25% времени)
3. **gRPC stream management** - минимальный overhead (10% времени)

## Поведение под нагрузкой:
1. **При легкой нагрузке (<= 50 пользователей):** оба подхода работают хорошо, gRPC в 1.5-2 раза быстрее
2. **При средней нагрузке (50-120 пользователей):** gRPC сохраняет преимущество, REST начинает деградировать
3. **При высокой нагрузке (>= 120 пользователей):** REST сильно деградирует, gRPC держится до 160 пользователей
4. **При длительной нагрузке:** gRPC показывает лучшую стабильность и меньшее потребление памяти

# Итоговый вывод для отчета
**gRPC демонстрирует значительные преимущества перед REST API:**
1. **Производительность:** В среднем на 50-60% быстрее по latency
2. **Эффективность:** На 43% меньше памяти, на 45% меньше сетевого трафика
3. **Стабильность:** Выдерживает на 33% больше пользователей перед деградацией
4. **Надежность:** В 2 раза меньше ошибок при одинаковой нагрузке
5. **Пропускная способность:** На 15% выше при длительной нагрузке

**Рекомендации:**

- Использовать **gRPC** для внутренней коммуникации между микросервисами
- Использовать **REST** для public API и интеграций с фронтендом
- Добавить кэширование **Redis** для часто запрашиваемых данных